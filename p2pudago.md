
<!-- saved from url=(0051)https://translate.googleusercontent.com/translate_f -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><pre>P2p's network discovery protocol uses the Kademlia protocol to handle node discovery on the network. Node lookups and node updates. The Kademlia protocol uses the UDP protocol for network communication.

Read this part of the code is recommended to look at the Kademlia protocol introduction in the references to see what is the Kademlia protocol.

First look at the data structure. The network transmits 4 kinds of data packets (UDP protocol is a message-based protocol. The transmission is one packet), which are ping, pong, findnode and neighbors. The format of the four types of messages is defined below.


// RPC packet types
Const (
pingPacket = iota + 1 // zero is 'reserved'
pongPacket
findnodePacket
neighborsPacket
)
// RPC request structures
Type (
Ping struct {
Version uint // protocol version
From, To rpcEndpoint //Source IP address Destination IP address
Expiration uint64 //Timeout
// Ignore additional fields (for forward compatibility).
// Fields that can be ignored. For forward compatibility
Rest []rlp.RawValue `rlp:"tail"`
}

// pong is the reply to ping.
// ping packet response
Pong struct {
// This field should mirror the UDP envelope address
// of the ping packet, which provides a way to discover the
// the external address (after NAT).
// destination IP address
To rpcEndpoint
// Explain that this pong package is responding to that ping packet. Contains the hash value of the ping packet
ReplyTok []byte // This contains the hash of the ping packet.
// The absolute time of the packet timeout. If this time is exceeded when the packet is received, the packet is considered timeout.
Expiration uint64 // Absolute timestamp at which the packet becomes invalid.
// Ignore additional fields (for forward compatibility).
Rest []rlp.RawValue `rlp:"tail"`
}
// findnode is used to query nodes that are closer to target
// findnode is a query for nodes close to the given target.
Findnode struct {
// destination node
Target NodeID // doesn't need to be an actual public key
Expiration uint64
// Ignore additional fields (for forward compatibility).
Rest []rlp.RawValue `rlp:"tail"`
}

// reply to findnode
// findnode response
Neighbors struct {
//The node value closer to the target.
Nodes []rpcNode
Expiration uint64
// Ignore additional fields (for forward compatibility).
Rest []rlp.RawValue `rlp:"tail"`
}

rpcNode struct {
IP net.IP // len 4 for IPv4 or 16 for IPv6
UDP uint16 // for discovery protocol
TCP uint16 // for RLPx protocol
ID NodeID
}

rpcEndpoint struct {
IP net.IP // len 4 for IPv4 or 16 for IPv6
UDP uint16 // for discovery protocol
TCP uint16 // for RLPx protocol
}
)


Two interface types are defined. The packet interface type should be assigned different handle methods for 4 different types of packages. The conn interface defines the functionality of a udp connection.


Type packet interface {
Handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error
Name() string
}

Type conn interface {
ReadFromUDP(b []byte) (n int, addr *net.UDPAddr, err error)
WriteToUDP(b []byte, addr *net.UDPAddr) (n int, err error)
Close() error
LocalAddr() net.Addr
}


The structure of udp, it should be noted that the last field *Table is an anonymous field in go. In other words, udp can directly call the method of the anonymous field Table.


// udp implements the RPC protocol.
Type udp struct {
Conn conn //network connection
Netrestrict *netutil.Netlist
Priv *ecdsa.PrivateKey / / private key, its own ID is generated by this.
ourEndpoint rpcEndpoint

Addpending chan *pending // used to apply for a pending
Gotreply chan reply // queue used to get the response

Closing chan struct{} // queue for closing
Nat nat.Interface

*Table
}



Pending and reply structures. The structure of the communication between the two internal user's go routines.


// pending represents a pending reply.
// some implementations of the protocol wish to send more than one
// reply packet to findnode. in general, any neighbors packet cannot
// be matched up with a specific findnode packet.
// our implementation handles this by storing a callback function for
// each pending reply. incoming packets from a node are dispatched
// to all the callback functions for that node.
// pending structure represents waiting for a reply
// We do this by storing a callback for each pending reply. All packets from a node are assigned to the corresponding callback of this node.
Type pending struct {
// these fields must match in the reply.
From NodeID
Ptype byte

// time when the request must complete
Deadline time.Time

// callback is called when a matching reply arrives. if it returns
// true, the callback is removed from the pending reply queue.
// if it returns false, the reply is considered incomplete and
// the callback will be invoked again for the next matching reply.
// If the return value is true. Then the callback will be removed from the queue. If it returns false, then the reply is not completed yet, and will continue to wait for the next reply.
Callback func(resp interface{}) (done bool)

// errc receives nil when the callback indicates completion or an
// error if no further reply is received within the timeout.
Errc chan&lt;- error
}

Type reply struct {
From NodeID
Ptype byte
Data interface{}
// loop indicates whether there was was
// a matching request by sending on this channel.
/ / By sending a message to this channel to indicate a match to a request.
Matched chan&lt;- bool
}


UDP creation

// ListenUDP returns a new table that listens for UDP packets on laddr.
Func ListenUDP(priv *ecdsa.PrivateKey, laddr string, natm nat.Interface, nodeDBPath string, netrestrict *netutil.Netlist) (*Table, error) {
Addr, err := net.ResolveUDPAddr("udp", laddr)
If err != nil {
Return nil, err
}
Conn, err := net.ListenUDP("udp", addr)
If err != nil {
Return nil, err
}
Tab, _, err := newUDP(priv, conn, natm, nodeDBPath, netrestrict)
If err != nil {
Return nil, err
}
log.Info("UDP listener up", "self", tab.self)
Return tab, nil
}

Func newUDP(priv *ecdsa.PrivateKey, c conn, natm nat.Interface, nodeDBPath string, netrestrict *netutil.Netlist) (*Table, *udp, error) {
Udp := &amp;udp{
Conn: c,
Priv: priv,
Netrestrict: netrestrict,
Closing: make(chan struct{}),
Gotreply: make(chan reply),
Addpending: make(chan *pending),
}
Realaddr := c.LocalAddr().(*net.UDPAddr)
If natm != nil { //natm nat mapping is used to get the external network address
If !realaddr.IP.IsLoopback() { //If the address is a local loopback address
Go nat.Map(natm, udp.closing, "udp", realaddr.Port, realaddr.Port, "ethereum discovery")
}
// TODO: react to external IP changes over time.
If ext, err := natm.ExternalIP(); err == nil {
Realaddr = &amp;net.UDPAddr{IP: ext, Port: realaddr.Port}
}
}
// TODO: separate TCP port
udp.ourEndpoint = makeEndpoint(realaddr, uint16(realaddr.Port))
/ / Create a table will be introduced later. The main logic of Kademlia is implemented in this class.
Tab, err := newTable(udp, PubkeyID(&amp;priv.PublicKey), realaddr, nodeDBPath)
If err != nil {
Return nil, nil, err
}
udp.Table = tab //Anonymous field assignment

Go udp.loop() //go routine
Go udp.readLoop() //Used for network data reading.
Return udp.Table, udp, nil
}

The ping method and pending processing, before talking about pending is waiting for a reply. Here is a code to analyze how it is implemented waiting for reply.

The pending method sends the pending structure to addpending. It then waits for the message to be processed and received.

// ping sends a ping message to the given node and waits for a reply.
Func (t *udp) ping(toid NodeID, toaddr *net.UDPAddr) error {
// TODO: maybe check for ReplyTo field in callback to measure RTT
Errc := t.pending(toid, pongPacket, func(interface{}) bool { return true })
T.send(toaddr, pingPacket, &amp;ping{
Version: Version,
From: t.ourEndpoint,
To: makeEndpoint(toaddr, 0), // TODO: maybe use known TCP port from DB
Expiration: uint64(time.Now().Add(expiration).Unix()),
})
Return &lt;-errc
}
// pending adds a reply callback to the pending reply queue.
// see the documentation of type pending for a detailed explanation.
Func (t *udp) pending(id NodeID, ptype byte, callback func(interface{}) bool) &lt;-chan error {
Ch := make(chan error, 1)
p := &amp;pending{from: id, ptype: ptype, callback: callback, errc: ch}
Select {
Case t.addpending &lt;- p:
// loop will handle it
Case &lt;-t.closing:
Ch &lt;- errClosed
}
Return ch
}

Processing of the addpending message. The newUDP method was called when the udp was created. There are two goroutines launched inside. The loop() is used to process the pending message.


// loop runs in its own goroutine. it keeps track of
// the refresh timer and the pending reply queue.
Func (t *udp) loop() {
Var (
Plist = list.New()
Timeout = time.NewTimer(0)
nextTimeout *pending // head of plist when timeout was last reset
contTimeouts = 0 // number of continuous timeouts to do NTP checks
ntpWarnTime = time.Unix(0, 0)
)
&lt;-timeout.C // ignore first timeout
Defer timeout.Stop()

resetTimeout := func() {
/ / The main function of this method is to check whether there is a pending message in the queue that needs to time out. If there is. Then
/ / Wake up according to the timeout of the first timeout.
If plist.Front() == nil || nextTimeout == plist.Front().Value {
Return
}
// Start the timer so it fires when the next pending reply has expired.
Now := time.Now()
For el := plist.Front(); el != nil; el = el.Next() {
nextTimeout = el.Value.(*pending)
If dist := nextTimeout.deadline.Sub(now); dist &lt; 2*respTimeout {
timeout.Reset(dist)
Return
}
// Remove pending replies whose deadline is too far in the
// future. These can occur if the system clock jumped
// backwards after the deadline was assigned.
// If the deadline for a message is in the far future, set the timeout directly and then remove it.
/ / This situation may occur when the system time is modified, if not processed may cause blocking for too long.
nextTimeout.errc &lt;- errClockWarp
plist.Remove(el)
}
nextTimeout = nil
timeout.Stop()
}

For {
resetTimeout() //First handles the timeout.

Select {
Case &lt;-t.closing: //Received the message. Timeout all blocked queues
For el := plist.Front(); el != nil; el = el.Next() {
el.Value.(*pending).errc &lt;- errClosed
}
Return

Case p := &lt;-t.addpending: //Add a pending to set the deadline
P.deadline = time.Now().Add(respTimeout)
plist.PushBack(p)

Case r := &lt;-t.gotreply: //received a reply to find a matching pending
Var matched bool
For el := plist.Front(); el != nil; el = el.Next() {
p := el.Value.(*pending)
If p.from == r.from &amp;&amp; p.ptype == r.ptype { //If from the same person. And the same type
Matched = true
// Remove the matcher if its callback indicates
// that all replies have been received. This is
// required for packet types that expect multiple
// reply packets.
If p.callback(r.data) { //If the callback return value is true. Description pending has been completed. Write nil to p.errc. Pending completed.
P.errc &lt;- nil
plist.Remove(el)
}
// Reset the continuous timeout counter (time drift detection)
contTimeouts = 0
}
}
R.matched &lt;- matched //write reply matched

Case now := &lt;-timeout.C: //Process timeout information
nextTimeout = nil

// Notify and remove callbacks whose deadline is in the past.
For el := plist.Front(); el != nil; el = el.Next() {
p := el.Value.(*pending)
If now.After(p.deadline) || now.Equal(p.deadline) { //If timeout writes timeout information and removes
P.errc &lt;- errTimeout
plist.Remove(el)
contTimeouts++
}
}
// If we've accumulated too many timeouts, do an NTP time sync check
If contTimeouts &gt; ntpFailureThreshold {
/ / If the timeout is repeated many times. Then check if the time is out of sync. Synchronize with the NTP server.
If time.Since(ntpWarnTime) &gt;= ntpWarningCooldown {
ntpWarnTime = time.Now()
Go checkClockDrift()
}
contTimeouts = 0
}
}
}
}

See the handling of pending above. However, the loop() method also has a gotreply handler. This is actually generated in the goroutine of readLoop().

// readLoop runs in its own goroutine. it handles incoming UDP packets.
Func (t *udp) readLoop() {
Defer t.conn.Close()
// Discovery packets are defined to be no larger than 1280 bytes.
// Packets larger than this size will be cut at the end and
// as invalid because their hash won't match.
Buf := make([]byte, 1280)
For {
Nbytes, from, err := t.conn.ReadFromUDP(buf)
If netutil.IsTemporaryError(err) {
// Ignore temporary read errors.
log.Debug("Temporary UDP read error", "err", err)
Continue
} else if err != nil {
// Shut down the loop for permament errors.
log.Debug("UDP read error", "err", err)
Return
}
t.handlePacket(from, buf[:nbytes])
}
}

Func (t *udp) handlePacket(from *net.UDPAddr, buf []byte) error {
Packet, fromID, hash, err := decodePacket(buf)
If err != nil {
log.Debug("Bad discv4 packet", "addr", from, "err", err)
Return err
}
Err = packet.handle(t, from, fromID, hash)
log.Trace("&lt;&lt; "+packet.name(), "addr", from, "err", err)
Return err
}

Func (req *ping) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
If expired(req.Expiration) {
Return errExpired
}
T.send(from, pongPacket, &amp;pong{
To: makeEndpoint(from, req.From.TCP),
ReplyTok: mac,
Expiration: uint64(time.Now().Add(expiration).Unix()),
})
If !t.handleReply(fromID, pingPacket, req) {
// Note: we're ignoring the provided IP address right now
Go t.bond(true, fromID, from, req.From.TCP)
}
Return nil
}

Func (t *udp) handleReply(from NodeID, ptype byte, req packet) bool {
Matched := make(chan bool, 1)
Select {
Case t.gotreply &lt;- reply{from, ptype, req, matched}:
// loop will handle it
Return &lt;-matched
Case &lt;-t.closing:
Return false
}
}


The general process of udp is described above. The following describes the main processing business of udp. Udp mainly sends two kinds of requests, and the corresponding ones also receive the two kinds of requests sent by others, and two kinds of responses are generated corresponding to the two kinds of requests.

Ping request, you can see that the ping request wants to get a pong answer. Then return.

// ping sends a ping message to the given node and waits for a reply.
Func (t *udp) ping(toid NodeID, toaddr *net.UDPAddr) error {
// TODO: maybe check for ReplyTo field in callback to measure RTT
Errc := t.pending(toid, pongPacket, func(interface{}) bool { return true })
T.send(toaddr, pingPacket, &amp;ping{
Version: Version,
From: t.ourEndpoint,
To: makeEndpoint(toaddr, 0), // TODO: maybe use known TCP port from DB
Expiration: uint64(time.Now().Add(expiration).Unix()),
})
Return &lt;-errc
}

Pong replies that if the pong answer does not match a corresponding ping request. Then return the errUnsolicitedReply exception.

Func (req *pong) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
If expired(req.Expiration) {
Return errExpired
}
If !t.handleReply(fromID, pongPacket, req) {
Return errUnsolicitedReply
}
Return nil
}

The findnode request, send a findnode request, and then wait for the node to respond to k neighbors.

// findnode sends a findnode request to the given node and waits until
// the node has sent up to k neighbors.
Func (t *udp) findnode(toid NodeID, toaddr *net.UDPAddr, target NodeID) ([]*Node, error) {
Nodes := make([]*Node, 0, bucketSize)
Nreceived := 0
Errc := t.pending(toid, neighborsPacket, func(r interface{}) bool {
Reply := r.(*neighbors)
For _, rn := range reply.Nodes {
Nreceived++
n, err := t.nodeFromRPC(toaddr, rn)
If err != nil {
log.Trace("Invalid neighbor node received", "ip", rn.IP, "addr", toaddr, "err", err)
Continue
}
Nodes = append(nodes, n)
}
Return nreceived &gt;= bucketSize
})
T.send(toaddr, findnodePacket, &amp;findnode{
Target: target,
Expiration: uint64(time.Now().Add(expiration).Unix()),
})
Err := &lt;-errc
Return nodes, err
}

Neighbors respond, very simple. Send the response to the gotreply queue. If no matching findnode request is found. Return errUnsolicitedReply error

Func (req *neighbors) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
If expired(req.Expiration) {
Return errExpired
}
If !t.handleReply(fromID, neighborsPacket, req) {
Return errUnsolicitedReply
}
Return nil
}



Receive a ping request sent by another node and send a pong reply. If the previous pending is not matched (indicating that it is not the result of the request). Call the bond method to add this node to its own bucket cache. (This part of the principle will be described in detail in table.go)

Func (req *ping) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
If expired(req.Expiration) {
Return errExpired
}
T.send(from, pongPacket, &amp;pong{
To: makeEndpoint(from, req.From.TCP),
ReplyTok: mac,
Expiration: uint64(time.Now().Add(expiration).Unix()),
})
If !t.handleReply(fromID, pingPacket, req) {
// Note: we're ignoring the provided IP address right now
Go t.bond(true, fromID, from, req.From.TCP)
}
Return nil
}

Received a findnode request from someone else. This request wants to send back k nodes that are close to the target. For details on the algorithm, please refer to the pdf document in the references directory.


Func (req *findnode) handle(t *udp, from *net.UDPAddr, fromID NodeID, mac []byte) error {
If expired(req.Expiration) {
Return errExpired
}
If t.db.node(fromID) == nil {
// No bond exists, we don't process the packet. This prevents
// an attack vector where the discovery protocol could be used
// to amplify traffic in a DDOS attack. A malicious actor
// would send a findnode request with the IP address and UDP
// port of the target as the source address. The recipient of
// the findnode packet would then send a neighbors packet
// (which is a much bigger packet than findnode) to the victim.
Return errUnknownNode
}
Target := crypto.Keccak256Hash(req.Target[:])
t.mutex.Lock()
//Get the bucketSize nodes that are close to the target. This method is implemented inside table.go. Follow-up details
Closest := t.closest(target, bucketSize).entries
t.mutex.Unlock()

p := neighbors{Expiration: uint64(time.Now().Add(expiration).Unix())}
// Send neighbors in chunks with at most maxNeighbors per packet
// to stay below the 1280 byte limit.
For i, n := range closest {
If netutil.CheckRelayIP(from.IP, n.IP) != nil {
Continue
}
p.Nodes = append(p.Nodes, nodeToRPC(n))
If len(p.Nodes) == maxNeighbors || i == len(closest)-1 {
T.send(from, neighborsPacket, &amp;p)
p.Nodes = p.Nodes[:0]
}
}
Return nil
}


### udp information encryption and security issues
Since the discover protocol does not carry any sensitive data, the data is transmitted in clear text, but in order to ensure the integrity of the data and not to be tampered with, a digital signature is added to the header of the packet.


Func encodePacket(priv *ecdsa.PrivateKey, ptype byte, req interface{}) ([]byte, error) {
b := new(bytes.Buffer)
b.Write(headSpace)
b.WriteByte(ptype)
If err := rlp.Encode(b, req); err != nil {
log.Error("Can't encode discv4 packet", "err", err)
Return nil, err
}
Packet := b.Bytes()
Sig, err := crypto.Sign(crypto.Keccak256(packet[headSize:]), priv)
If err != nil {
log.Error("Can't sign discv4 packet", "err", err)
Return nil, err
}
Copy(packet[macSize:], sig)
// add the hash to the front. Note: this doesn't protect the
// packet in any way. Our public key will be part part this hash in
// The future.
Copy(packet, crypto.Keccak256(packet[macSize:]))
Return packet, nil
}

Func decodePacket(buf []byte) (packet, NodeID, []byte, error) {
If len(buf) &lt; headSize+1 {
Return nil, NodeID{}, nil, errPacketTooSmall
}
Hash, sig, sigdata := buf[:macSize], buf[macSize:headSize], buf[headSize:]
Shouldhash := crypto.Keccak256(buf[macSize:])
If !bytes.Equal(hash, shouldhash) {
Return nil, NodeID{}, nil, errBadHash
}
fromID, err := recoverNodeID(crypto.Keccak256(buf[headSize:]), sig)
If err != nil {
Return nil, NodeID{}, hash, err
}
Var req packet
Switch ptype := sigdata[0]; ptype {
Case pingPacket:
Req = new(ping)
Case pongPacket:
Req = new(pong)
Case findnodePacket:
Req = new(findnode)
Case neighborsPacket:
Req = new(neighbors)
Default:
Return nil, fromID, hash, fmt.Errorf("unknown type: %d", ptype)
}
s := rlp.NewStream(bytes.NewReader(sigdata[1:]), 0)
Err = s.Decode(req)
Return req, fromID, hash, err
}</pre></body></html>