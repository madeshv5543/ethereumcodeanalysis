
<!-- saved from url=(0051)https://translate.googleusercontent.com/translate_f -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></head><body><pre>Recently considering the implementation of a decentralized casino based on Ethereum, a random number is necessary if the casino needs to be implemented. Then I studied the random number generation in Ethereum and found it not easy.


There are several ways to generate random numbers in Ethereum.


# oraclize
Oraclize is positioned as a data porter for decentralized applications as a reliable link to Web APIs and DApps. With Oraclize, there is no need to build an extra chain of trust because our behavior has been forced to be encrypted. Oraclize is a provable and honest oracle service that allows smart contracts to access the Internet. Oraclize is platform-independent and provides a virtual interface to all major smart contract platforms. It is conceivable that investing a lot of meaningful data into the blockchain through Oraclize can make the smart contract industry more prosperous and make more valuable applications more vital.

The usage of Oraclize can be found in the following [code] (https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol)

Call the oraclize_newRandomDSQuery method in the update method to call the Oracle smart contract code.
Oracle generates the corresponding data based on the request, and then passes the result through the callback __callback.

/*
Oraclize random-datasource example

This contract uses the random-datasource to securely generate off-chain N random bytes
*/

Pragma solidity ^0.4.11;

Import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

Contract RandomExample is usingOraclize {

Event newRandomNumber_bytes(bytes);
Event newRandomNumber_uint(uint);

Function RandomExample() {
oraclize_setProof(proofType_Ledger); // sets the Ledger authenticity proof in the constructor
Update(); // let's ask for N random bytes immediately when the contract is created!
}

// the callback function is called by Oraclize when the result is ready
// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:
// the proof validity is fully verified on-chain
Function __callback(bytes32 _queryId, string _result, bytes _proof)
{
// if we reach this point successfully, it means that the attached authenticity proof has passed!
If (msg.sender != oraclize_cbAddress()) throw;

If (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
// the proof verification has failed, do we need to take any action here? (depends on the use case)
} else {
// the proof verification has passed
// now that we know that the random number was safely generated, let's use it..

newRandomNumber_bytes(bytes(_result)); // this is the resulting random number (bytes)

// for simplicity of use, let's also convert the random bytes to uint if we need
Uint maxRange = 2**(8* 7); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the Datasource to return
Uint randomNumber = uint(sha3(_result)) % maxRange; // this is an efficient way to get the uint out in the [0, maxRange] range

newRandomNumber_uint(randomNumber); // this is the resulting random number (uint)
}
}

Function update() payable {
Uint N = 7; // number of random bytes we want the datasource to return
Uint delay = 0; // number of seconds to wait before the execution takes place
Uint callbackGas = 200000; // amount of gas we want Oraclize to set for the callback function
Bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas); // this function internally generates the correct oraclize_query and returns its queryId
}

}

Consider a smart contract that offers betting.
The user invokes the betting interface, which stores the user's request and then invokes the Oracle random number generation service.
Then through the Oracle callback service, determine whether the random number is greater than a certain value. If it is established, the user succeeds, otherwise the user fails.

This is the typical Oracle use case.






# RANDAO: A DAO working as RNG of Ethereum

[randao](https://github.com/randao/randao) is a decentralized organization that generates Ethereum random numbers.

**Random number in programming is very important!**

**RNG in a deterministic system is very difficult**

**Miners can't be trusted!**

Random numbers are very important in programming.
RNG is very difficult in a deterministic system.
Can't believe miners

## solution
Solutions

A DAO (decentralised autonomous organisation) that anyone can participate in, and the random number is generated by all participants together! First of all, we need to create a RANDAO contract in the blockchain, which defines the participation rules. Then the basic process of Generating a random number can be divided into three phases:

A DAO (decentralized anonymous organization) allows anyone to join, and random numbers are generated by all participants working together. First, we need to create a smart contract for RANDAO on the blockchain, and the contract defines the participation rules. Then the basic process of generating a random number can be divided into the following three steps:

**The first phase: collecting valid sha3(s)**

Anyone who want to participate in the random number generation needs to send a transaction to the contract C with m ETH as pledge in a specified time period (eg, 6 block period, approximately 72s), accompanied by the result of sha3(s), s is the secret number respective extracted by participant.

**Step 1: Collect effective sha3(s)**
Participants participating in random number generation first need to send m ETH as a mortgage to smart contract C in a specified time interval (for example, a range of 6 blocks, about 72 seconds), while sending a value of sha3(s) to the smart Contract C, s is a number that only the participants know.

**The second phase: collecting valid s**

After the first phase, anyone who submitted sha3(s) successfully needs to send a transaction with the secret number s in the first stage to contract C within a specified time period. Contract C will check if s is valid by running sha3 against s and Comparing the result with previous committed data. Valid s will be saved to the collecting of seeds to finally generate the random number.

**Step 2: Collect valid s**

At the end of the first step, those who submitted sha3(s) need to send s to the smart contract C within the specified time interval. Smart Contract C will check if sha3(s) is the same as the previously submitted value. The same s will be saved to the seed set for the final generation of random numbers.

**The third phase: calculating a random number, refund pledged ETH and bonus**

- After all secret numbers have been successfully collected, contract C will calculate the random number from the function f(s1,s2,...,sn), the result will be written to the storage of C, and the result will be sent To all other contracts that requested the random number before.
- Contract C will send back the pledge to the participants in the first phase, and the profit is divided into equal parts and sent to all participants as an additional bonus. The profit comes from the fees that is paid by other contracts that consume the random Number.

**Step 3: Calculate random numbers, return mortgages and bonuses**

- After all the secret numbers s have been successfully collected, Smart Contract C will use the function f(s1, s2,...,sn) to calculate the random number. The result of the random number will be written to the smart contract storage, and the result will be It is sent to all other smart contracts that previously requested random numbers.
- Smart Contract C will return the first stage of the mortgage to the participants, and the bonus will be distributed equally to all participants. The bonus comes from other smart contracts that request random values.

## Additional rules

In order to ensure the RNG can't be manipulated, as well as for safety and efficiency, the contract C has the following additional rules:

- The first phase, if two or more of the same sha3(s) are submitted in sequence, only the first one is accepted.

- The first phase, there is a requirement for minimum number of participants, if it fails to collect enough sha3(s) within the time period, then RNG at this block height will fail.

- If a participant submits the sha3(s) and it is accepted by contract C, he must reveal the s in the second phase.

- If the participant fails to reveal s in the second phase, then the m ETH sent in the first phase will be confiscated without providing a return.

- If one or more s isn't revealed in the second phase, RNG at this block height will fail. Confiscated ETHs will be divided equally and send to other participants who revealed s at the second phase. The fees paid by other contracts will be Refunded.

Supplementary rule

To ensure that RNG cannot be manipulated, and for safety and efficiency, Smart Contract C has the following additional rules:

- In the first step, if two or more of the same sha3(s) are submitted, only the first one will be accepted.
- In the first step, there is a minimum requirement for the participant. If there is not enough value of sha3(s) collected within the specified time interval, then the RNG will fail at this block height.
- If the participant submits sha3(s), then he must submit s in the second step.
- If the participant does not submit s in the second step, then the m ETH provided in the first stage will be forfeited and no reward.
- If one or more s are not submitted in the second step, the RNG will fail at this block height. The forfeited ETH will be distributed equally to other participants who submitted s. Other fees for other contracts that apply for a random number will be refunded.

## Incentive

The RNG cycle is very short, and could be for example 20 cycles in one hour, if one cycle's profit is 0.001% , the monthly rate of return is up to 0.00001 * 20 * 24 * 30 = 0.144. Targeting to 14.4% monthly rate Of return, and RNG has n participants on average, the running costs of contract is n * 3 * 500 * gasPrice + Ccost. (Ccost is gas consumed by contract internal, including computing and storage, etc. ) Assuming each random numbers has r Time requests on average, the call price is p ETH, the income is r * p. So each participant will get (rp - 1500n * gasPrice - Ccost) / n from one time participation. The current gasPrice is 10 szabo, and estimate of Contract consumption is 1500n gas, so estimate of net income is (rp / n - 0.03) ETH. Assuming each RNG has 10 participation, and the pledge is 1000ETH, the minimum required income is 0.4 ETH, which over 0.001% profit in this case So if the RNG is requested only once, the service price is 0.4 ETH, and if it is requested 10 times, the Price is just 0.04 ETH for each request.

excitation

The cycle of RNG is very short, for example, 20 generation cycles per hour. If the profit without cycle is 0.001%, the profit for one month will reach 0.00001 * 20 * 24 * 30 = 0.144. In order to achieve a profit of 14.4% per month, and RNG has an average of n participants, the cost of running Smart Contract C is n * 3 * 500 * gasPrice + Ccost. (CCost is the gas consumption within the contract, including calculation and storage) Assuming that each random value has an average of r requests, the cost per request is p ETH, then the revenue is r*p. So each participant receives rp - 1500n * gasPrice - Ccost / n for each participation. The current gasPrice is 10 szabo, the contract consumption is about 1500n gas, so the approximate net income is (rp/n-0.03) ETH. Suppose each RNG has 10 participants and the mortgage is 1000ETH, so if RNG only Request once, then the cost is 0.4 ETH, if the request is 10 times, then the price of one request will be reduced to 0.04ETH


The RAND ACT acts as an infrastructure in the Ethereum system. It is called by other contracts. Contracts for different purposes require different random numbers: some need high security, such as lottery; some need steady responses and the request should be responded immediately, these contracts Are normally low-value; some need a callback, they want to receive a notification with random numbers when numbers are ready.

Obviously it's impossible to meet different requirements in various scenarios with only one RNG contract, so a lot of contracts will be created with different initial parameters, but the basic rules are the same.

RANDAO is the infrastructure of the Ethereum system. Called by other contracts. Different contracts require different random values ​​because they have different purposes: some require highly encrypted, such as lottery; some require a stable response, and require immediate response, the value of these contracts is not high; some require a callback function, A notification needs to be received when a random value has been generated.

Obviously it is not possible to satisfy all the different requests through a single RNG contract, so a lot of smart contracts are created using different initial values, but their basic rules are the same.


For example, if we need high security, we can substantially increase the pledge of the first phase. Thus, the cost of leading to failure of RNG process by not revealing s is greatly increased. And for the contracts without much interest involved, the minimum Number of participants and the pledge can be lower.

Let's look at an example of a dApp betting on odd or even numbers, we'll show how to adjust the contract's parameters to meet the desired security level, by making the cost of cheating higher than expected earnings. Assuming the bet is 1000 ETH, The betting contract calls a RNG contract C1, if C1 failed to generate a random number at requested block height, then betting contract waits for the next random number of C1, until there is one generated.

For example, if you need a high level of security, we can greatly increase the mortgage for the first phase. The probability that failure will not be provided by s will be greatly reduced. For a contract where the funds are not sufficient, then the minimum number of participants and the mortgage can be reduced.

Let's look at an example of a dapp. This example is used to sing odd and even numbers. We will show how to adjust the parameters of the contract to match the appropriate level of security, by making the cost of fraud much higher than the benefit. Assuming that the bet is 1000 ETH, the bet contract calls the contract C1 of the RNG. If C1 fails to generate a random number at the requested block height, the bet contract will wait for the next random number of C1 until one is successfully generated.

Let's build the RNG contract C1, and set the pledged ETH of C1 to 2000. The gambler G plays the betting dApp but also participates in the contract. When he finds himself in a disadvantageous position before he reveals his secret number, he can choose not To reveal s, so that the RNG failed and he got another chance. But he will lose the 2000 pledged ETH, so although he can get 1000 ETH expected return, it is still a bad deal. However, G can reduce his losses on C1 If some means, such as participating in C1 using two accounts, sending two sha3(s). if in a disadvantageous position, G will keep only one account's secret, and if only one participant expect G participate to in C1, G will only lose 1000 ETH in C1, but G will get 1000 ETH as expected return, which is a worthy try.

Let's build the RNG smart contract C1 and set the value of the mortgage to 2000. Gambler G participated in the dApp bet and participated in the RNG smart contract. Before he submitted s, he found himself in an unfavorable state. He can choose not to submit his own s, so RNG will fail and he will get the next chance. But he will lose the 2000 ETH mortgage, although he can get a 1000 ETH bet, so this is not a good deal. However, gambler G can use other methods to reduce losses. For example, G can use two accounts to participate in RNG and send two sha3(s). If it is in an unfavorable state, G will let an account not submit s, so if G is excluded There is only one other account besides, G will only lose 1000 ETH on G1, but G can get 1000 ETH if it wins, so it is worth a try.

This issue can be fixed by confiscating the pledged ETH, and not return them to participants as bonus. so a contract with 1000 pledged ETH will meet the requirement of the betting dApp.

This situation can be fixed by confiscation of all mortgages and will not be returned as a reward. So a 1000 mortgage contract will meet the gambling requirements.

To be a member you must pay dues, anyone paid their dues is a member. Members have different levels according to the dues they paid. Membership does not belong To a contract, but instead functions like a passport to participate in some RANDAO contracts. If a breach of any contract happens, that person's membership will be ended and the dues will be confiscated. Now we can add an additional agreement to C1, C1 will Only accept numbers committed by members whose level of investment is high enough (membership dues over 1000 ETH). This will ensure that nobody has a financial motive to try an attack.

In addition to confiscation, there is a program to stop this attack, which is RANDAO membership. In order to become a member, you must pay membership fees. The members are divided into different levels according to the amount of fees paid by the members. The member system does not belong to the smart contract, but participates in some RANDAO contracts as a form of passport-like. In the event of a default, the membership of this member will be terminated and members will be forfeited. Now we can add an additional agreement to smart contract C1. C1 only accepts members who will participate with more than a certain value. This ensures that no one has financial incentives to launch an attack.


## QA: Quest and Answer

Q: Why not let the miners participate in RNG? Why not use tx hash, nonce and other blockchain data? A: Miners have the ability to manipulate these blockchain data, and thus can indirectly affect RNG. If RNG contains blockchain data, it will Give the miners capacity to construct random numbers in their favor.

Q: Why not let the miners participate in the RNG? Why not use txhash, nonce or other blockchain data? A: Miners have the ability to manipulate these blockchain data, which can have an impact on RNG. If the RNG contains blockchain data, it will give the miners the ability to construct random numbers according to their own behavior.

Q: the miners can ignore certain transactions that contain random number they dislike, how to deal with that? A: That's why we need a time window period. A reasonable period should be greater than 6 blocks, we believe that nobody can produce 6 blocks In succession. So if the participant is honest, and he send numbers immediately as long as each time window open, he doesn't need to worry about being excluded.

Q: Miners have the ability to ignore specific transactions that contain random numbers. How do you deal with this situation? A: That's why we need time intervals. A reasonable time interval will be greater than 6 blocks, and no one in our mission can generate 6 blocks in succession. So if the participant is loyal and sends that number in the time window, then he is differently worried that he will be excluded by the miners.

Q: Why use all numbers of all participants, rather than a subset? A: The rule to pick a subset is deterministic, so participants will try to take specified position of the collection by various means, if they succeed, they will know in advance What the random number is generating from subsets. If the rule to pick a subset is randomised, then we still have the problem of true randomisation.

Q: Why use all the values ​​of all participants, not their subset? A: The rules for selecting a subset are deterministic, so participants will try to collect the specified collection locations in various ways, and if they succeed, they will know the random numbers generated from the subset in advance. If the rules for selecting a subset are random, then we still have a real randomization problem.

Q: Where does pledged dues go? A: It will be donated to a charity, or RANDAO to maintain funding. Q: Where is the confiscation fee? Will donate to charity, or RANDAO will maintain a fund.

Note: f(s1, s2, ..., sn) is a function with multiple inputs, for example r = s1 xor s2 xor s3 ... xor sn, or r = sha3(sn + sha3(sn-1 + . .. (sha3(s2 + s1))))

</pre></body></html>